// Code generated by go-swagger; DO NOT EDIT.

package streaming

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// StreamGetReader is a Reader for the StreamGet structure.
type StreamGetReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *StreamGetReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 101:
		result := NewStreamGetSwitchingProtocols()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 400:
		result := NewStreamGetBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 401:
		result := NewStreamGetUnauthorized()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		return nil, runtime.NewAPIError("[GET /api/v1/streaming] streamGet", response, response.Code())
	}
}

// NewStreamGetSwitchingProtocols creates a StreamGetSwitchingProtocols with default headers values
func NewStreamGetSwitchingProtocols() *StreamGetSwitchingProtocols {
	return &StreamGetSwitchingProtocols{}
}

/*
StreamGetSwitchingProtocols describes a response with status code 101, with default header values.

StreamGetSwitchingProtocols stream get switching protocols
*/
type StreamGetSwitchingProtocols struct {
	Payload *StreamGetSwitchingProtocolsBody
}

// IsSuccess returns true when this stream get switching protocols response has a 2xx status code
func (o *StreamGetSwitchingProtocols) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this stream get switching protocols response has a 3xx status code
func (o *StreamGetSwitchingProtocols) IsRedirect() bool {
	return false
}

// IsClientError returns true when this stream get switching protocols response has a 4xx status code
func (o *StreamGetSwitchingProtocols) IsClientError() bool {
	return false
}

// IsServerError returns true when this stream get switching protocols response has a 5xx status code
func (o *StreamGetSwitchingProtocols) IsServerError() bool {
	return false
}

// IsCode returns true when this stream get switching protocols response a status code equal to that given
func (o *StreamGetSwitchingProtocols) IsCode(code int) bool {
	return code == 101
}

// Code gets the status code for the stream get switching protocols response
func (o *StreamGetSwitchingProtocols) Code() int {
	return 101
}

func (o *StreamGetSwitchingProtocols) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[GET /api/v1/streaming][%d] streamGetSwitchingProtocols %s", 101, payload)
}

func (o *StreamGetSwitchingProtocols) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[GET /api/v1/streaming][%d] streamGetSwitchingProtocols %s", 101, payload)
}

func (o *StreamGetSwitchingProtocols) GetPayload() *StreamGetSwitchingProtocolsBody {
	return o.Payload
}

func (o *StreamGetSwitchingProtocols) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(StreamGetSwitchingProtocolsBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewStreamGetBadRequest creates a StreamGetBadRequest with default headers values
func NewStreamGetBadRequest() *StreamGetBadRequest {
	return &StreamGetBadRequest{}
}

/*
StreamGetBadRequest describes a response with status code 400, with default header values.

bad request
*/
type StreamGetBadRequest struct {
}

// IsSuccess returns true when this stream get bad request response has a 2xx status code
func (o *StreamGetBadRequest) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this stream get bad request response has a 3xx status code
func (o *StreamGetBadRequest) IsRedirect() bool {
	return false
}

// IsClientError returns true when this stream get bad request response has a 4xx status code
func (o *StreamGetBadRequest) IsClientError() bool {
	return true
}

// IsServerError returns true when this stream get bad request response has a 5xx status code
func (o *StreamGetBadRequest) IsServerError() bool {
	return false
}

// IsCode returns true when this stream get bad request response a status code equal to that given
func (o *StreamGetBadRequest) IsCode(code int) bool {
	return code == 400
}

// Code gets the status code for the stream get bad request response
func (o *StreamGetBadRequest) Code() int {
	return 400
}

func (o *StreamGetBadRequest) Error() string {
	return fmt.Sprintf("[GET /api/v1/streaming][%d] streamGetBadRequest", 400)
}

func (o *StreamGetBadRequest) String() string {
	return fmt.Sprintf("[GET /api/v1/streaming][%d] streamGetBadRequest", 400)
}

func (o *StreamGetBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	return nil
}

// NewStreamGetUnauthorized creates a StreamGetUnauthorized with default headers values
func NewStreamGetUnauthorized() *StreamGetUnauthorized {
	return &StreamGetUnauthorized{}
}

/*
StreamGetUnauthorized describes a response with status code 401, with default header values.

unauthorized
*/
type StreamGetUnauthorized struct {
}

// IsSuccess returns true when this stream get unauthorized response has a 2xx status code
func (o *StreamGetUnauthorized) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this stream get unauthorized response has a 3xx status code
func (o *StreamGetUnauthorized) IsRedirect() bool {
	return false
}

// IsClientError returns true when this stream get unauthorized response has a 4xx status code
func (o *StreamGetUnauthorized) IsClientError() bool {
	return true
}

// IsServerError returns true when this stream get unauthorized response has a 5xx status code
func (o *StreamGetUnauthorized) IsServerError() bool {
	return false
}

// IsCode returns true when this stream get unauthorized response a status code equal to that given
func (o *StreamGetUnauthorized) IsCode(code int) bool {
	return code == 401
}

// Code gets the status code for the stream get unauthorized response
func (o *StreamGetUnauthorized) Code() int {
	return 401
}

func (o *StreamGetUnauthorized) Error() string {
	return fmt.Sprintf("[GET /api/v1/streaming][%d] streamGetUnauthorized", 401)
}

func (o *StreamGetUnauthorized) String() string {
	return fmt.Sprintf("[GET /api/v1/streaming][%d] streamGetUnauthorized", 401)
}

func (o *StreamGetUnauthorized) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	return nil
}

/*
StreamGetSwitchingProtocolsBody stream get switching protocols body
swagger:model StreamGetSwitchingProtocolsBody
*/
type StreamGetSwitchingProtocolsBody struct {

	// The type of event being received.
	//
	// `update`: a new status has been received.
	// `notification`: a new notification has been received.
	// `delete`: a status has been deleted.
	// `filters_changed`: filters (including keywords and statuses) have changed.
	// Enum: ["update","notification","delete","filters_changed"]
	Event string `json:"event,omitempty"`

	// The payload of the streamed message.
	// Different depending on the `event` type.
	//
	// If present, it should be parsed as a string.
	//
	// If `event` = `update`, then the payload will be a JSON string of a status.
	// If `event` = `notification`, then the payload will be a JSON string of a notification.
	// If `event` = `delete`, then the payload will be a status ID.
	// If `event` = `filters_changed`, then there is no payload.
	// Example: {\"id\":\"01FC3TZ5CFG6H65GCKCJRKA669\",\"created_at\":\"2021-08-02T16:25:52Z\",\"sensitive\":false,\"spoiler_text\":\"\",\"visibility\":\"public\",\"language\":\"en\",\"uri\":\"https://gts.superseriousbusiness.org/users/dumpsterqueer/statuses/01FC3TZ5CFG6H65GCKCJRKA669\",\"url\":\"https://gts.superseriousbusiness.org/@dumpsterqueer/statuses/01FC3TZ5CFG6H65GCKCJRKA669\",\"replies_count\":0,\"reblogs_count\":0,\"favourites_count\":0,\"favourited\":false,\"reblogged\":false,\"muted\":false,\"bookmarked\":falsâ€¦//gts.superseriousbusiness.org/fileserver/01JNN207W98SGG3CBJ76R5MVDN/header/original/019036W043D8FXPJKSKCX7G965.png\",\"header_static\":\"https://gts.superseriousbusiness.org/fileserver/01JNN207W98SGG3CBJ76R5MVDN/header/small/019036W043D8FXPJKSKCX7G965.png\",\"followers_count\":33,\"following_count\":28,\"statuses_count\":126,\"last_status_at\":\"2021-08-02T16:25:52Z\",\"emojis\":[],\"fields\":[]},\"media_attachments\":[],\"mentions\":[],\"tags\":[],\"emojis\":[],\"card\":null,\"poll\":null,\"text\":\"a\"}
	Payload string `json:"payload,omitempty"`

	// stream
	Stream []string `json:"stream"`
}

// Validate validates this stream get switching protocols body
func (o *StreamGetSwitchingProtocolsBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateEvent(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStream(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var streamGetSwitchingProtocolsBodyTypeEventPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["update","notification","delete","filters_changed"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		streamGetSwitchingProtocolsBodyTypeEventPropEnum = append(streamGetSwitchingProtocolsBodyTypeEventPropEnum, v)
	}
}

const (

	// StreamGetSwitchingProtocolsBodyEventUpdate captures enum value "update"
	StreamGetSwitchingProtocolsBodyEventUpdate string = "update"

	// StreamGetSwitchingProtocolsBodyEventNotification captures enum value "notification"
	StreamGetSwitchingProtocolsBodyEventNotification string = "notification"

	// StreamGetSwitchingProtocolsBodyEventDelete captures enum value "delete"
	StreamGetSwitchingProtocolsBodyEventDelete string = "delete"

	// StreamGetSwitchingProtocolsBodyEventFiltersChanged captures enum value "filters_changed"
	StreamGetSwitchingProtocolsBodyEventFiltersChanged string = "filters_changed"
)

// prop value enum
func (o *StreamGetSwitchingProtocolsBody) validateEventEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, streamGetSwitchingProtocolsBodyTypeEventPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (o *StreamGetSwitchingProtocolsBody) validateEvent(formats strfmt.Registry) error {
	if swag.IsZero(o.Event) { // not required
		return nil
	}

	// value enum
	if err := o.validateEventEnum("streamGetSwitchingProtocols"+"."+"event", "body", o.Event); err != nil {
		return err
	}

	return nil
}

var streamGetSwitchingProtocolsBodyStreamItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["user","public","public:local","hashtag","hashtag:local","list","direct"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		streamGetSwitchingProtocolsBodyStreamItemsEnum = append(streamGetSwitchingProtocolsBodyStreamItemsEnum, v)
	}
}

func (o *StreamGetSwitchingProtocolsBody) validateStreamItemsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, streamGetSwitchingProtocolsBodyStreamItemsEnum, true); err != nil {
		return err
	}
	return nil
}

func (o *StreamGetSwitchingProtocolsBody) validateStream(formats strfmt.Registry) error {
	if swag.IsZero(o.Stream) { // not required
		return nil
	}

	for i := 0; i < len(o.Stream); i++ {

		// value enum
		if err := o.validateStreamItemsEnum("streamGetSwitchingProtocols"+"."+"stream"+"."+strconv.Itoa(i), "body", o.Stream[i]); err != nil {
			return err
		}

	}

	return nil
}

// ContextValidate validates this stream get switching protocols body based on context it is used
func (o *StreamGetSwitchingProtocolsBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *StreamGetSwitchingProtocolsBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *StreamGetSwitchingProtocolsBody) UnmarshalBinary(b []byte) error {
	var res StreamGetSwitchingProtocolsBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
